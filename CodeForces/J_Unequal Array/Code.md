# 题解

## 1. 我的题解
```cpp
#include <bits/stdc++.h>
using namespace std;

int main(){
    ios::sync_with_stdio(false);
    cin.tie(NULL);

    int t;
    cin>>t;
    while(t--){
        int n;
        cin>>n;
        vector<int> arr(n);
        for(int i=0;i<n;i++) cin>>arr[i];

        vector<int> o;
        for(int i=0;n>(i+1);i++){
            if(arr[i] == arr[i+1]) o.push_back(i);
        }
        if(o.size() <= 1){
            cout << 0 << '\n';
        } else {
            int count = max(1, o.back() - o.front() - 1);
            cout << count << '\n';
        }
    }
    return 0;
}
```


### 思路
先收集数组中所有相邻相等元素的位置，若这些位置数量≤1则无需操作；否则，计算第一个和最后一个相邻相等位置的间距，最少操作次数为该间距减一与1的较大值，通过针对这些相邻相等对的集中区间进行操作，使数组的相等度最终≤1。

> 要想到这个解法，核心是**洞察“相邻相等对的连续性”与“操作的覆盖性”之间的关系**：
首先，问题的本质是通过修改相邻元素对，打破大部分“相邻相等关系”，最终只保留≤1对。而每次操作可以修改一个相邻对（i和i+1），并可能影响其左右的相邻对（打破或形成新的相等对）。
通过观察发现：所有相邻相等对若“集中成片”（即它们的位置是连续或接近连续的），则只需针对这片区域的**起始和结束位置**计算操作次数。因为这些相邻相等对的影响范围被限制在“第一个相邻相等位置”到“最后一个相邻相等位置”之间，操作次数由这个区间的长度决定——区间越长，需要的操作越多，最终推导出用 `max(1, 最后位置 - 第一个位置 - 1)` 即可计算最少操作次数。
这种思路是对“相邻相等对的分布模式”的提炼：将零散的多对问题转化为“区间长度”的单一维度问题，从而实现高效求解。

> 没看懂？没事，这里还有另一个解释方法：
因为数列中的每一个相同的相邻数，只能对第二个元素以及其下一个数进行操作以去除这一对，但是代价是又添加了一对，我们仅仅是将不满足要求的数对向右平移了一个位置。
但是这个数对在向右的过程中也可以吞噬其它不满足要求的数对，使得整个数列中不满足要求的只有这个数对，这就是我们所期望的。
于是，我们自然就可以让它从第一个不满足要求的数对开始吞噬一直到最后一个不满足要求的数对，这样所有不满足要求的数对就被这个数对独揽。

时间复杂度是 O(t × n)。
<br>
<br>

## 2. 别人的题解
```cpp
#include <bits/stdc++.h>
#define endl '\n'
#define AC return 0;
using namespace std;
int a[200005];
void slove()
{
        int n;
        cin >> n;
        for(int i = 1; i <= n; i++)
            cin >> a[i];
        int l = n,r = 1;
        int cnt = 0;
        for(int i = 2; i <= n; i++)
        {
            if(a[i] == a[i - 1])
            {
                l = min(l,i - 1);
                r = max(r,i);
                cnt++;
            }
        }
        if(cnt < 2)
            cout << 0 << endl;
        else
        {
            int k = r - l - 1;
            if(k == 1)
                cout << 1 << endl;
            else
                cout << k - 1 << endl;
        }   
}
signed main()
{
        ios::sync_with_stdio(false);
        cin.tie(0);
        cout.tie(0);
        int T;
        cin >> T;
        while(T--)
            slove();
        AC
}
```

### 思路
思路相同，但写法不同，还是利用最左边有相同相邻数字的索引和最右边有相同相邻数字的索引，作r-l-1计算，得到答案。

> 有很多题解都提到 $a=[1,1,1]$ 这个特例，但这两个解法都很好地解决了。

