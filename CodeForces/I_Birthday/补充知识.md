# 补充知识：
## 1. deque
在 C++ 标准库中，`deque`（全称 double-ended queue，双端队列）是一种**序列容器**，专门优化了“在两端快速插入/删除元素”的场景，同时支持随机访问。下面从多个维度详细介绍：


### 一、是什么？
`deque` 是 STL（标准模板库）中的容器，核心特性是：  
- **双端操作高效**：在容器的头部（front）和尾部（back）插入或删除元素的时间复杂度为 **O(1)**（常数时间）。  
- **随机访问支持**：可以像数组一样通过下标（`[]` 或 `at()`）直接访问任意位置的元素，时间复杂度为 **O(1)**。  
- **内存布局**：内部由**多个连续的内存块**组成（而非像 `vector` 那样是单一连续内存块），通过一个“控制块”（指针数组）管理这些内存块，平衡了灵活性和访问效率。  


### 二、怎么用？
#### 1. 必备条件
需包含头文件 `<deque>`（`#include <deque>`），且元素类型需支持拷贝/移动（基础类型如 `int`、`string` 等默认支持）。


#### 2. 基本操作（示例代码）
```cpp
#include <iostream>
#include <deque>
using namespace std;

int main() {
    // 1. 初始化
    deque<int> dq;  // 空双端队列
    deque<int> dq2(3, 10);  // 3个元素，均为10（{10,10,10}）
    deque<int> dq3 = {1, 2, 3, 4};  // 初始化列表（{1,2,3,4}）


    // 2. 两端插入元素（O(1)）
    dq.push_back(5);  // 尾部添加：dq = {5}
    dq.push_front(0);  // 头部添加：dq = {0,5}
    dq.push_back(6);  // 尾部添加：dq = {0,5,6}


    // 3. 两端删除元素（O(1)）
    dq.pop_back();  // 删除尾部：dq = {0,5}
    dq.pop_front();  // 删除头部：dq = {5}


    // 4. 随机访问（O(1)）
    deque<int> dq4 = {10, 20, 30, 40};
    cout << dq4[1] << endl;  // 下标访问（无越界检查）：20
    cout << dq4.at(2) << endl;  // at()访问（有越界检查，抛异常）：30
    cout << dq4.front() << endl;  // 访问头部：10
    cout << dq4.back() << endl;  // 访问尾部：40


    // 5. 遍历（支持迭代器）
    for (int num : dq4) {  // 范围for循环
        cout << num << " ";  // 10 20 30 40
    }
    cout << endl;

    for (auto it = dq4.begin(); it != dq4.end(); ++it) {  // 迭代器遍历
        cout << *it << " ";  // 10 20 30 40
    }
    cout << endl;


    // 6. 其他常用操作
    cout << "大小：" << dq4.size() << endl;  // 元素个数：4
    dq4.clear();  // 清空容器：dq4 变为空
    cout << "是否为空：" << (dq4.empty() ? "是" : "否") << endl;  // 是

    return 0;
}
```


### 三、什么时候用？
`deque` 的核心适用场景是**需要在两端频繁插入/删除，且需要随机访问元素**的场景，例如：  
1. **实现双端队列**：需要同时支持“队头出队”和“队尾入队”（如 BFS 算法中动态扩展队列）。  
2. **滑动窗口问题**：窗口的左右边界可能频繁移动（左侧移除、右侧添加），且需要快速访问窗口内的元素。  
3. **替代 `vector` 处理头部操作**：当需要在头部插入/删除元素（`vector` 头部操作是 O(n) 复杂度，效率低），但又需要随机访问时。  


### 四、为什么用？
选择 `deque` 而非其他容器（如 `vector`、`list`）的核心原因是平衡了**双端操作效率**和**随机访问能力**：  
- 对比 `vector`：`vector` 尾部操作高效（O(1)），但头部操作需要移动所有元素（O(n)）；而 `deque` 头部和尾部操作均为 O(1)，且扩容时无需整体拷贝所有元素（内存块分段管理）。  
- 对比 `list`（双向链表）：`list` 两端操作也是 O(1)，但随机访问需要遍历（O(n)）；而 `deque` 支持 O(1) 随机访问，更适合需要直接访问中间元素的场景。  


### 五、优势与劣势
#### 优势：
1. **双端操作高效**：头部/尾部插入（`push_front`/`push_back`）和删除（`pop_front`/`pop_back`）均为 O(1) 时间复杂度，远超 `vector` 的头部操作（O(n)）。  
2. **随机访问便捷**：支持下标访问（`[]`）和 `at()` 函数，时间复杂度 O(1)，优于 `list` 的 O(n) 随机访问。  
3. **内存管理灵活**：采用分段内存块存储，避免了 `vector` 因单一连续内存块导致的大规模扩容拷贝（`vector` 扩容时可能需要将所有元素拷贝到新内存）。  


#### 劣势：
1. **内存开销更大**：需要额外的“控制块”（指针数组）管理内存块，且每个内存块有一定的冗余空间，内存利用率低于 `vector`。  
2. **中间操作低效**：在容器中间插入/删除元素时，需要移动该位置前后的元素（类似 `vector`），时间复杂度为 O(n)，不如 `list` 的 O(1) 中间操作。  
3. **迭代器稳定性较差**：虽然比 `vector` 好（`vector` 扩容会导致所有迭代器失效），但 `deque` 在头部/尾部插入时可能导致部分迭代器失效（例如扩展内存块时，控制块的指针可能变化）。  


### 总结
`deque` 是“双端高效操作”和“随机访问”的平衡者，适合需要在两端频繁操作且需直接访问元素的场景。若仅需尾部操作，`vector` 更轻量；若需大量中间操作，`list` 更合适；若需双端+随机访问，`deque` 是最优选择。
<br>

<br>

<br>

## 2. sort()
在 C++ 标准库中，`sort()` 是最常用的排序函数，定义于 `<algorithm>` 头文件，用于对序列（容器或数组）进行高效排序。它是 STL（标准模板库）的核心工具之一，底层实现经过高度优化，兼顾了性能和通用性。


### 一、是什么？
`sort()` 是 C++ 标准库提供的**通用排序算法**，核心特性：  
- **排序逻辑**：默认按“升序”排列元素（基于元素的 `<` 运算符），也支持自定义排序规则（如降序、按结构体某字段排序等）。  
- **底层实现**：采用**内省排序（introsort）** 算法，这是一种混合排序策略：  
  - 首先使用**快速排序**（平均时间复杂度 `O(n log n)`，适合大规模数据）；  
  - 当递归深度过大时，切换为**堆排序**（最坏时间复杂度 `O(n log n)`，避免快速排序在极端情况下的 `O(n²)` 退化）；  
  - 当数据规模较小时（通常小于 16 个元素），切换为**插入排序**（小规模数据下常数时间开销更小）。  
- **迭代器要求**：要求序列支持**随机访问迭代器**（如 `vector`、`array`、普通数组等），不支持双向迭代器（如 `list`）。  


### 二、怎么用？
#### 1. 必备条件
- 包含头文件 `<algorithm>`（`#include <algorithm>`）。  
- 待排序的序列需支持随机访问迭代器（如 `vector`、`array`、`int[]` 等）。  
- 元素类型需支持比较（基础类型如 `int`、`string` 等默认支持 `<`；自定义类型需显式定义比较规则）。  


#### 2. 基本语法
```cpp
// 基础用法：对 [first, last) 区间升序排序
sort(first, last);

// 扩展用法：用自定义比较函数 comp 排序
sort(first, last, comp);
```
- `first`：指向排序区间**起始位置**的迭代器（或指针）。  
- `last`：指向排序区间**尾后位置**的迭代器（或指针）（即排序范围是 `[first, last)`，不包含 `last` 指向的元素）。  
- `comp`：可选的比较函数（或函数对象、lambda 表达式），定义排序规则（返回 `true` 表示第一个参数应排在第二个参数之前）。  


#### 3. 示例代码
```cpp
#include <iostream>
#include <vector>
#include <algorithm> // 必须包含
using namespace std;

// 示例1：对 vector<int> 升序排序（默认）
void test1() {
    vector<int> vec = {3, 1, 4, 1, 5, 9};
    sort(vec.begin(), vec.end()); // 排序范围：整个容器
    // 结果：{1, 1, 3, 4, 5, 9}
    for (int num : vec) cout << num << " ";
    cout << endl;
}

// 示例2：对普通数组降序排序（自定义比较函数）
bool greaterInt(int a, int b) {
    return a > b; // 定义“a 应排在 b 前”的规则（降序）
}
void test2() {
    int arr[] = {5, 2, 7, 3};
    int n = sizeof(arr) / sizeof(arr[0]);
    sort(arr, arr + n, greaterInt); // 排序范围：arr[0] 到 arr[n-1]
    // 结果：{7, 5, 3, 2}
    for (int num : arr) cout << num << " ";
    cout << endl;
}

// 示例3：对结构体按字段排序（用 lambda 表达式）
struct Student {
    string name;
    int score;
};
void test3() {
    vector<Student> students = {
        {"Alice", 85},
        {"Bob", 92},
        {"Charlie", 78}
    };
    // 按 score 升序排序（用 lambda 定义比较规则）
    sort(students.begin(), students.end(), 
        [](const Student& a, const Student& b) {
            return a.score < b.score; 
        });
    // 结果：Charlie(78) → Alice(85) → Bob(92)
    for (auto& s : students) {
        cout << s.name << "(" << s.score << ") ";
    }
}

int main() {
    test1();
    test2();
    test3();
    return 0;
}
```


### 三、什么时候用？
`sort()` 是**通用排序需求的首选工具**，适合以下场景：  
1. 需要对序列（容器或数组）进行排序，且无需保留相等元素的原始相对顺序（即不需要稳定排序）。  
2. 依赖有序序列进行后续操作（如二分查找 `binary_search`、去重 `unique`、统计最值等）。  
3. 算法中需要预处理步骤（如贪心算法、动态规划中对输入数据排序）。  
4. 对排序性能有要求（需 `O(n log n)` 时间复杂度），且数据规模可大可小（`sort()` 对不同规模数据均有优化）。  


### 四、为什么用？
选择 `sort()` 而非手动实现排序算法（如快速排序、冒泡排序）的核心原因是：  
1. **性能优异**：底层的内省排序结合了多种算法的优势，平均和最坏时间复杂度均接近 `O(n log n)`，远优于简单排序（如冒泡排序 `O(n²)`）。  
2. **通用性强**：支持所有随机访问容器（`vector`、`array`、普通数组等）和多种元素类型（基础类型、自定义结构体等）。  
3. **使用灵活**：通过自定义比较函数，可轻松实现升序、降序、按字段排序等各种规则，无需修改算法本身。  
4. **可靠性高**：标准库实现经过严格测试，避免了手动实现可能的边界错误（如快速排序的 pivot 选择不当导致退化）。  
5. **代码简洁**：一行代码即可完成排序，减少冗余逻辑，提高开发效率。  


### 五、优势与劣势
#### 优势：
1. **高效性**：时间复杂度稳定在 `O(n log n)`（平均和最坏情况），对大规模数据性能优异。  
2. **灵活性**：支持自定义排序规则，适配各种排序需求（如降序、结构体多字段排序）。  
3. **通用性**：兼容所有随机访问容器，无需为不同容器单独实现排序逻辑。  
4. **简洁性**：调用简单，一行代码替代数十行手动排序逻辑，降低出错概率。  


#### 劣势：
1. **不稳定排序**：相等元素的相对顺序可能被改变（例如原始序列 `[2, 1, 2]` 排序后可能变为 `[1, 2, 2]`，但两个 `2` 的原始位置可能交换）。若需要稳定排序，需使用 `stable_sort()`（时间复杂度相同，但常数开销略高）。  
2. **依赖随机访问迭代器**：不支持双向迭代器容器（如 `list`），这类容器需使用自带的 `list::sort()` 方法（双向链表专用排序）。  
3. **自定义类型需显式比较**：对自定义结构体/类，必须手动定义比较规则（重载 `<` 或提供 `comp` 函数），否则无法编译。  


### 总结
`sort()` 是 C++ 中排序的“瑞士军刀”，凭借 `O(n log n)` 的高效性、灵活的自定义规则和广泛的适用性，成为绝大多数排序场景的首选。它的核心价值是**用简洁可靠的方式解决排序问题**，避免重复实现复杂算法。唯一需要注意的是：若需稳定排序或操作链表，需选择 `stable_sort()` 或容器自带的排序方法。


> 普通数组和vector的整体sort用法不一样:
普通数组：sort(arr, arr + n); 
vector：sort(vec.begin(), vec.end()); 


