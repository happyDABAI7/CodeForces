# 题解

## 1. 我的题解
```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(NULL);

    int t;
    if (!(cin >> t)) return 0;
    while (t--) {
        long long n;
        cin >> n;
        long long sum = 0;
        long long p = 1;

        while (p <= n) {
            long long next = p * 10;
            long long f = n / next;
            sum += f * 45LL * p;

            long long r = n % next;
            long long l = r / p;

            sum += (l * (l - 1) / 2) * p;
            sum += l * (r % p + 1);

            p = next;
        }

        cout << sum << '\n';
    }
    return 0;
}
```

### 思路
这段代码通过“按数位分段计算”的思路，高效求解1到n所有数字的各位数字之和：将每个数位（个位、十位、百位等）的贡献独立拆分，分别计算高位完整循环（0~9）的总和与当前位部分循环（0到该位数字）的总和，累加所有数位贡献即得结果。此方法无需遍历每个数字，时间复杂度仅与n的位数相关（O(log₁₀n)），能高效处理极大的n（如1e18）。

直接记住就好，下次直接用。

时间复杂度为 O(t × log₁₀n)。
<br>
<br>

## 2. 别人的题解
### 前缀和+查表
```cpp
#include <bits/stdc++.h> 
using namespace std;
const int N = 2e5+5;
int f[200005]={0}; 
int dig(int x){  //计算整数x的各位数字之和
	int cnt = 0;
	while(x/10>0){
		cnt+=x%10;
		x/=10;
	}
	if(x)cnt+=x;
	return cnt;
}
int main(){
	for(int i=1;i<N;i++) f[i]=f[i-1]+dig(i);  //构造前缀和数组
	int t;
	cin>>t
	while(t--){
		int n;
		cin>>n;
		cout<<f[n]<<"\n";  //直接查表
	}
	return 0;
}
```

### 思路
因为 $n≤2×10e5$ ，所以我们可以预处理出 $1∼2×10e5$的所有数的数位和。
直接预处理 $1∼2×10e5$ 的前缀和，每次 O(1) 查询即可。

时间复杂度为O(N + t)。

> 预处理的方式，可以让代码更简洁高效。

#### ??? dig(x)函数的时间复杂度不计入吗？

`dig(x)` 函数的时间复杂度**是计入的**，但由于其复杂度是**有界的小常数级别**，在整体分析中会被归为“常数因子”，不影响最终的时间复杂度阶数。


### 详细解释：
1. **`dig(x)` 的时间复杂度**：  
   `dig(x)` 用于计算 `x` 的各位数字之和，循环次数等于 `x` 的**位数**（例如 `x=123` 有3位，循环3次；`x=99999` 有5位，循环5次）。  
   一个数 `x` 的位数 `d` 满足 `d = log₁₀x + 1`（向下取整），因此 `dig(x)` 的时间复杂度是 **O(log₁₀x)**（对数级）。  


2. **为什么整体分析中不单独强调？**  
   在预处理阶段（`for(int i=1;i<N;i++)`），`i` 的最大值是 `N-1=2e5`（即200000），其位数最多为 **6位**（`200000` 是6位数）。因此，`dig(i)` 的循环次数最多为6次，`log₁₀i` 是**有界的小常数**（≤6）。  

   在时间复杂度分析中，**常数因子会被忽略**（例如 O(6×N) 等价于 O(N)）。因此，虽然 `dig(x)` 的复杂度是 O(log x)，但由于 `log x` 在这里是固定的小常数，整个预处理阶段的时间复杂度仍被简化为 **O(N)**。  


3. **总结**：  
   `dig(x)` 的时间复杂度是计入的，但其量级（对数级且有界）在整体分析中被归为常数因子，不改变最终的时间复杂度阶数（预处理阶段仍为 O(N)，总复杂度仍为 O(N + t)）。  

   这种简化是时间复杂度分析的常规做法——关注“随输入规模增长的趋势”，而非具体的常数倍数。



