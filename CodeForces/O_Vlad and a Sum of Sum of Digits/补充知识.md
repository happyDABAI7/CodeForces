# 补充知识：
## 1. 前缀和

在 C++ 中，**前缀和**是一种针对“区间求和”问题的预处理技术，核心是通过提前计算并存储“前 n 个元素的累积和”，将后续的区间和查询从 O(n) 优化到 O(1)。以下从多个维度系统总结：


### 一、是什么？
前缀和是一个**辅助数组**，其每个元素 `s[i]` 表示“原数组中前 i 个元素的总和”。  
- 对于一维数组 `a[0...n-1]`，前缀和数组 `s` 的定义为：  
  `s[0] = 0`（通常从 0 开始，方便计算），  
  `s[i] = a[0] + a[1] + ... + a[i-1]`（即前 i 个元素的和，`i ≥ 1`）。  
- 例如：原数组 `a = [1, 2, 3, 4]`，则前缀和数组 `s = [0, 1, 3, 6, 10]`（`s[1]=1`，`s[2]=1+2=3`，以此类推）。  


### 二、怎么用？
#### 1. 核心步骤（一维前缀和）
##### （1）预处理：计算前缀和数组
```cpp
vector<int> a = {1, 2, 3, 4}; // 原数组
int n = a.size();
vector<int> s(n + 1, 0); // 前缀和数组，大小为n+1，s[0]=0
for (int i = 1; i <= n; ++i) {
    s[i] = s[i - 1] + a[i - 1]; // 递推公式：前i个和 = 前i-1个和 + 第i个元素（a[i-1]）
}
```

##### （2）查询：计算区间 [l, r] 的和（0 ≤ l ≤ r < n）
区间和公式：`sum(l, r) = s[r + 1] - s[l]`  
- 例如：查询 `a[1...2]`（即元素 2、3）的和：`s[3] - s[1] = 6 - 1 = 5`，与 2+3 结果一致。  


#### 2. 扩展：二维前缀和（用于矩阵子矩阵和）
对于二维矩阵 `a[0...n-1][0...m-1]`，前缀和数组 `s[i][j]` 表示“以 (0,0) 为左上角、(i-1,j-1) 为右下角的子矩阵的和”。  
- 预处理公式：`s[i][j] = a[i-1][j-1] + s[i-1][j] + s[i][j-1] - s[i-1][j-1]`（容斥原理，避免重复计算）。  
- 查询公式：子矩阵 `(x1,y1) 到 (x2,y2)` 的和 = `s[x2+1][y2+1] - s[x1][y2+1] - s[x2+1][y1] + s[x1][y1]`。  


### 三、什么时候用？
前缀和的核心适用场景是：**需要多次查询“数组/矩阵中某段区间的和”，且原数组很少被修改**。具体包括：  
1. 一维数组的区间和查询（如多次查询 `a[l...r]` 的和）。  
2. 二维矩阵的子矩阵和查询（如多次查询 `(x1,y1) 到 (x2,y2)` 的和）。  
3. 具有“累积性”的问题（如本文中“1到n的各位数字之和”，本质是每个数字的各位和的前缀和）。  


### 四、为什么用？
前缀和的核心价值是**用“预处理的时间”换“查询的时间”**，解决“重复计算”问题：  
- 若不使用前缀和，每次查询区间 `[l, r]` 的和需要遍历 `r-l+1` 个元素，时间复杂度 O(n)；若有 t 次查询，总复杂度 O(t×n)。  
- 使用前缀和后，预处理仅需 O(n) 时间，每次查询仅需 O(1) 时间，总复杂度降至 O(n + t)，在多查询场景下效率提升显著（例如 n=1e5、t=1e5 时，从 1e10 操作降至 2e5 操作）。  


### 五、优势与劣势
#### 优势：
1. **实现简单**：仅需一次遍历即可预处理，代码逻辑直观，无需复杂数据结构。  
2. **查询高效**：将区间和查询从 O(n) 优化到 O(1)，适合多查询场景。  
3. **通用性强**：不仅适用于数组，还可扩展到矩阵（二维前缀和），甚至更高维度（但实际中二维已足够）。  


#### 劣势：
1. **不适合频繁修改**：若原数组元素被修改，前缀和数组需要重新计算（修改一个元素会导致后续所有前缀和变化），时间复杂度 O(n)，效率极低。此时需用**线段树**或**树状数组**（支持 O(log n) 修改和查询）。  
2. **功能单一**：仅能高效解决“区间和”问题，无法直接处理区间最大值、最小值等其他区间查询（需其他数据结构）。  


### 总结
前缀和是“区间求和+多查询”场景的“性价比之王”，以简单的预处理实现了查询效率的质的飞跃。但需注意其局限性：仅适用于“少修改、多查询”的场景，若有频繁修改或复杂区间查询需求，需搭配其他数据结构。