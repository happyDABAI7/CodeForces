# 补充知识：
## 1. vector

在C++中，`vector`是标准模板库（STL）提供的**动态数组容器**，属于序列式容器，用于存储同类型元素，支持动态扩容。以下从「使用方法」「适用场景」「优缺点」三个方面总结其核心知识点：


### 一、vector的基本使用方法
#### 1. 头文件与定义
使用`vector`需包含头文件 `<vector>`，并通过模板指定元素类型：
```cpp
#include <vector>
using namespace std;

// 定义一个存储int类型的vector（默认初始化，空容器）
vector<int> v1;

// 定义存储double类型的vector
vector<double> v2;
```


#### 2. 初始化方式
`vector`支持多种初始化方式，根据需求选择：
```cpp
// 1. 指定初始大小（元素为默认值，int默认0，string默认空）
vector<int> v(5);  // 包含5个int元素，值均为0（size=5）

// 2. 指定大小+初始值
vector<int> v(5, 10);  // 包含5个int元素，值均为10（size=5）

// 3. 列表初始化（C++11及以上）
vector<int> v = {1, 2, 3, 4};  // 元素为1,2,3,4（size=4）
vector<int> v{1, 2, 3, 4};     // 同上

// 4. 拷贝初始化（复制另一个vector的元素）
vector<int> v1{1,2,3};
vector<int> v2(v1);  // v2 = {1,2,3}

// 5. 迭代器范围初始化（复制[begin, end)区间的元素）
vector<int> v1{1,2,3,4};
vector<int> v2(v1.begin()+1, v1.end()-1);  // v2 = {2,3}
```


#### 3. 核心操作（增删改查）
##### （1）添加元素
- **尾部添加**：`push_back(val)`（效率高，O(1)，需注意扩容成本）
  ```cpp
  vector<int> v;
  v.push_back(1);  // v = {1}
  v.push_back(2);  // v = {1,2}
  ```
- **指定位置插入**：`insert(迭代器位置, val)` 或 `insert(位置, n, val)`（插入n个val），效率低（O(n)，需移动后续元素）
  ```cpp
  vector<int> v{1,3};
  v.insert(v.begin()+1, 2);  // 在索引1处插入2 → v = {1,2,3}
  v.insert(v.end(), 2, 4);   // 在末尾插入2个4 → v = {1,2,3,4,4}
  ```


##### （2）删除元素
- **尾部删除**：`pop_back()`（效率高，O(1)）
  ```cpp
  vector<int> v{1,2,3};
  v.pop_back();  // v = {1,2}
  ```
- **指定位置删除**：`erase(迭代器位置)` 或 `erase(开始位置, 结束位置)`（删除区间元素），效率低（O(n)，需移动后续元素）
  ```cpp
  vector<int> v{1,2,3,4};
  v.erase(v.begin()+1);      // 删除索引1的元素 → v = {1,3,4}
  v.erase(v.begin(), v.end());  // 删除所有元素 → v为空（等价于clear()）
  ```
- **清空所有元素**：`clear()`（仅清空元素，不释放底层内存，size变为0，capacity不变）


##### （3）访问与修改元素
- **随机访问**：通过 `[]` 或 `at(index)`（`at` 会检查越界，越界抛异常；`[]` 不检查，越界行为未定义）
  ```cpp
  vector<int> v{1,2,3};
  cout << v[0];   // 1（不检查越界）
  cout << v.at(1); // 2（检查越界，若index≥size则抛异常）
  ```
- **访问首尾元素**：`front()`（首元素）、`back()`（尾元素）
  ```cpp
  vector<int> v{1,2,3};
  cout << v.front();  // 1
  cout << v.back();   // 3
  ```
- **修改元素**：直接通过 `[]` 或 `at` 赋值
  ```cpp
  v[0] = 10;  // v变为{10,2,3}
  ```


##### （4）遍历元素
- **下标遍历**：适合需要索引的场景
  ```cpp
  for (int i = 0; i < v.size(); i++) {
      cout << v[i] << " ";
  }
  ```
- **迭代器遍历**：STL通用方式，支持所有容器
  ```cpp
  // 正向迭代器
  for (vector<int>::iterator it = v.begin(); it != v.end(); it++) {
      cout << *it << " ";
  }
  // 反向迭代器（从尾到头）
  for (vector<int>::reverse_iterator it = v.rbegin(); it != v.rend(); it++) {
      cout << *it << " ";
  }
  ```
- **范围for循环（C++11及以上）**：简洁，无需关心索引
  ```cpp
  for (int x : v) {
      cout << x << " ";
  }
  ```


#### 4. 容量与大小管理
- **`size()`**：返回当前元素个数（实际存储的元素数量）。
- **`capacity()`**：返回当前容器能容纳的最大元素数（底层已分配的内存大小，`capacity() ≥ size()`）。
- **`resize(n)`**：调整容器大小为n。若n>原size，新增元素为默认值；若n<原size，删除多余元素（`capacity` 不变）。
  ```cpp
  vector<int> v{1,2,3};
  v.resize(5);  // size=5，元素为{1,2,3,0,0}（capacity可能不变）
  v.resize(2);  // size=2，元素为{1,2}（capacity仍可能≥2）
  ```
- **`reserve(n)`**：预留至少能容纳n个元素的内存（仅改变`capacity`，不改变`size`）。若n≤当前`capacity`，则无操作；常用于提前分配内存，避免频繁扩容。
  ```cpp
  vector<int> v;
  v.reserve(100);  // capacity至少为100（size仍为0）
  ```
- **`empty()`**：判断容器是否为空（`size() == 0` 时返回`true`）。


### 二、什么时候使用vector？
`vector`的核心特性是「动态大小+随机访问高效」，适合以下场景：

1. **元素数量不确定**：需要动态添加/删除元素，且无法提前确定数组大小（避免C风格数组的固定大小限制）。  
   例：读取用户输入时，不确定输入数据的数量，用`vector`动态存储。

2. **需要频繁随机访问元素**：通过索引（`[]` 或 `at`）访问任意位置元素，时间复杂度为O(1)。  
   例：实现数组、矩阵（嵌套`vector`）、栈（仅尾部操作）等数据结构。

3. **主要在尾部操作元素**：`push_back`（尾部添加）和`pop_back`（尾部删除）效率高（O(1)，无扩容时）。  
   例：实现栈（LIFO）、存储动态增长的列表（如日志记录）。

4. **需要与C风格数组兼容**：`vector`的底层是连续内存，可以通过`data()`方法获取指向首元素的指针，直接传给需要C风格数组的函数（如`printf`、`memcpy`）。


### 三、vector的优缺点
#### 优点：
1. **动态管理内存**：无需手动分配/释放内存，容器自动处理扩容和内存回收，减少内存泄漏风险。  
2. **随机访问高效**：底层是连续内存，通过索引访问元素的时间复杂度为O(1)，优于`list`（链表，随机访问O(n)）。  
3. **尾部操作高效**：`push_back`和`pop_back`在不触发扩容时为O(1)，适合实现栈等结构。  
4. **兼容STL算法**：支持迭代器，可直接使用STL中的`sort`、`find`等算法（如`sort(v.begin(), v.end())`排序）。  
5. **与C数组兼容**：通过`data()`获取底层数组指针，方便与C语言接口交互。


#### 缺点：
1. **中间插入/删除效率低**：在非尾部位置插入或删除元素时，需要移动后续所有元素，时间复杂度为O(n)（远不如`list`的O(1)）。  
2. **扩容可能有性能开销**：当`size() == capacity()`时，`push_back`会触发扩容（通常是翻倍分配新内存，拷贝旧元素到新内存），此时单次操作耗时O(n)。  
3. **内存空间可能浪费**：`capacity`通常大于`size`（预留空间），若元素数量远小于`capacity`，会造成内存浪费。  
4. **不适合频繁扩容的场景**：频繁触发扩容会导致多次内存分配和拷贝，性能下降（可通过`reserve(n)`提前预留空间优化）。  
5. **多维数组灵活性低**：嵌套`vector`（如`vector<vector<int>>`）本质是“数组的数组”，每行内存不连续，且每行大小可不同，不适合需要严格连续内存的多维数组场景（此时可用`vector<int>`模拟，通过索引计算行列）。


### 总结
`vector`是C++中最常用的容器之一，本质是“动态连续数组”，核心优势是动态大小和高效随机访问，适合元素数量不确定、需频繁按索引访问或尾部操作的场景；但中间插入删除效率低、扩容有开销是其主要局限。使用时需根据具体操作场景（如是否频繁中间修改、是否需要随机访问）选择，与`list`、`deque`等容器配合使用可优化性能。

