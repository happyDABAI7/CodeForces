# 题解

## 1. 我的题解
```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
	ios::sync_with_stdio(false);
    cin.tie(NULL);
	
	int n,m;
	cin>>n>>m;
	int sum=0, j=n;
	vector< vector<int> > a;  //嵌套数组，二维数组
	while(j--){   // ！！！二维数组如何创建！！！！！！！！！
		vector<int> r;
		int i=m;
		while(i--){
			int t;
			cin>>t;
			r.push_back(t);
		}
		a.push_back(r);
	}

	int i=m;
	while(i--){
		j=n;
		int max=0;
		while(j--){
			if(a[j][i]>max) max=a[j][i];
		}
		sum+=max;
	}
	cout<<sum<<'\n';
}
```

### 思路
读取 n 行 m 列的矩阵，计算每一列的最大值并累加，最后输出总和。

时间复杂度：O (n×m)（读取矩阵和计算每列最大值均需遍历 n×m 个元素）。

这类通过部分交叉的信息求整体的问题，可以通过将交叉信息中最大值作为整体来解决。

> 这类问题，**本质是“表格类数据的分组统计与汇总问题”**：给定由行和列组成的表格数据，需先按行或列划分成多个小组，为每个小组计算一个关键值（如最大值等），最后将这些关键值汇总（如求和）得到结果。  
其中，这类问题中**常需计算“最大值”**，核心原因是问题的约束与目标共同决定的：若要求“每个小组的整体值必须大于等于组内所有局部值”（如班级学生数不能少于任何一种水果的喜欢人数），且目标是“让整体值尽可能小”（如总学生数最小），那么**每个小组的最大值就是该组整体值的最小合理值——比它小会违反约束，比它大则不符合“最小”的目标**。  
解决这类问题的通用高效方法是：**先明确按行还是按列分组，以及每个组要计算的关键值（如最大值）；然后遍历表格中所有数据，边遍历边实时更新每个组的关键值；最后将所有组的关键值汇总，得到结果**。
这种方式只需遍历一次数据，高效且直接。


