# 标准库stack

在C++标准库中，`stack`是一种**容器适配器**（container adapter），专门用于实现“后进先出（LIFO, Last In First Out）”的逻辑。以下从核心维度总结其知识点：


### 一、是什么？  
`stack`不是独立的容器，而是对底层容器（如`deque`、`vector`、`list`）的封装，仅暴露符合“后进先出”规则的接口。它屏蔽了底层容器的随机访问、迭代等功能，只保留“从顶端插入、从顶端删除、访问顶端元素”的操作，严格遵循LIFO原则。  

默认情况下，`stack`的底层容器是`deque`（双端队列），因为`deque`在两端的插入/删除操作效率均为`O(1)`，且避免了`vector`可能的内存重分配开销。


### 二、什么用？  
用于需要“最后插入的元素最先处理”的场景，典型应用包括：  
1. **函数调用栈模拟**：程序执行时，函数调用的上下文（参数、返回地址等）按LIFO顺序存储在栈中，返回时依次弹出。  
2. **表达式求值**：如后缀表达式（逆波兰式）的计算，运算符和操作数通过栈临时存储和处理。  
3. **括号匹配**：遍历字符串时，左括号入栈，遇到右括号时弹出栈顶左括号，判断是否匹配。  
4. **回溯算法**：如迷宫求解、全排列生成等，通过栈记录路径，无法继续时弹出最近的步骤回溯。  
5. **临时数据缓存**：需要按“最晚进入先处理”的顺序暂存数据（如浏览器的“后退”功能）。  


### 三、怎么用？  
#### 1. 基础使用步骤  
- 包含头文件：`#include <stack>`  
- 定义对象：`stack<数据类型, 底层容器类型> 栈名;`（底层容器可选，默认`deque`）  
- 核心操作：  

| 操作               | 功能描述                                  | 时间复杂度 |  
|--------------------|-------------------------------------------|------------|  
| `push(x)`          | 将元素`x`插入栈顶                        | `O(1)`     |  
| `pop()`            | 移除栈顶元素（**不返回值**）              | `O(1)`     |  
| `top()`            | 返回栈顶元素的引用（需先判空，否则未定义）| `O(1)`     |  
| `empty()`          | 判断栈是否为空（空返回`true`）            | `O(1)`     |  
| `size()`           | 返回栈中元素的个数                        | `O(1)`     |  


#### 2. 示例代码  
```cpp
#include <iostream>
#include <stack>
using namespace std;

int main() {
    stack<int> st; // 默认底层为deque<int>
    
    // 入栈
    st.push(10);
    st.push(20);
    st.push(30); // 栈顶为30，栈内：10 <- 20 <- 30（LIFO）
    
    // 访问栈顶
    cout << "栈顶元素：" << st.top() << endl; // 输出30
    
    // 出栈（移除栈顶）
    st.pop(); // 栈内变为：10 <- 20（栈顶20）
    
    // 遍历栈（需弹出元素，会清空栈）
    while (!st.empty()) {
        cout << st.top() << " "; // 输出20 10
        st.pop();
    }
    
    return 0;
}
```


#### 3. 自定义底层容器  
可指定`vector`或`list`作为底层容器（需支持`push_back`、`pop_back`、`back`操作）：  
```cpp
stack<int, vector<int>> st_vec; // 底层为vector
stack<int, list<int>> st_list;  // 底层为list
```


### 四、为什么用？  
1. **逻辑清晰**：`stack`的接口（`push`/`pop`/`top`）直接对应LIFO逻辑，无需手动维护“栈顶位置”等细节，代码可读性更高。  
2. **避免错误**：屏蔽了底层容器的随机访问（如`vector`的`[]`）和迭代器操作，强制只能从顶端操作，防止误修改非栈顶元素。  
3. **适配灵活**：可根据需求选择底层容器（如`vector`适合频繁访问栈顶，`list`适合频繁插入删除），无需重写核心逻辑。  


### 五、优势与劣势  
#### 优势：  
- **高效性**：所有操作均为`O(1)`，与底层容器的对应操作效率一致。  
- **封装性好**：仅暴露必要接口，专注于LIFO逻辑，降低使用成本。  
- **通用性强**：支持任意可复制/移动的数据类型（基础类型、自定义结构体等）。  


#### 劣势：  
- **功能有限**：不支持随机访问（如无法直接访问第`k`个元素），也不提供迭代器，无法遍历栈中所有元素（除非弹出元素）。  
- **依赖底层容器**：性能受底层容器影响（如`vector`作为底层时，频繁`push`可能触发内存重分配；`list`作为底层时，节点内存开销更大）。  
- **无边界检查**：`top()`或`pop()`在空栈上调用时，行为未定义（可能崩溃），需手动用`empty()`判断。  


### 六、重要注意事项  
1. **与`queue`的区别**：`stack`是LIFO，`queue`是FIFO（先进先出），接口类似但逻辑相反（`queue`用`front()`取队头，`push()`入队尾）。  
2. **底层容器选择**：默认`deque`是平衡选择；若需频繁`push`且内存连续，可选`vector`；若需频繁插入删除且内存灵活，可选`list`。  
3. **空栈操作风险**：必须在调用`top()`或`pop()`前用`empty()`判断栈是否为空，否则可能导致程序崩溃。  
4. **无法遍历**：若需查看所有元素（不弹出），`stack`不适用，需改用`vector`等容器手动模拟栈逻辑（维护`top`变量）。  


### 总结  
`stack`是实现LIFO逻辑的“轻量工具”，核心价值在于用简洁的接口封装了底层容器，让开发者专注于“后进先出”的业务逻辑，而非数据结构细节。适合所有需要按LIFO顺序处理数据的场景，但需注意其功能限制（如无迭代器、依赖底层容器）。


---

### 标准库stack和手动使用数组模拟栈的区别，彼此的优劣

两者本质都是实现“后进先出（LIFO）”逻辑，核心操作（入栈、出栈、取栈顶）的时间复杂度均为`O(1)`，但在**使用成本、灵活性、内存管理、适用场景**上差异明显，具体对比如下：


### 一、核心区别（维度对比）
| 对比维度         | 标准库`stack`                          | 数组模拟栈（`int st[N]; int top=-1`）  |
|------------------|----------------------------------------|---------------------------------------|
| 实现本质         | 容器适配器，封装底层容器（默认`deque`） | 直接使用连续数组，手动维护栈顶指针`top` |
| 使用门槛         | 低，接口直观（`push/pop/top`）         | 中，需手动管理`top`（`++/--`）和边界  |
| 功能限制         | 严格遵循LIFO，无迭代器、不可随机访问   | 可随机访问数组任意位置（可能破坏栈逻辑） |
| 内存管理         | 底层容器（`deque/vector`）动态扩容     | 需提前指定数组大小（固定或动态申请）  |
| 错误风险         | 低（屏蔽底层细节，仅暴露必要接口）     | 高（易出现`top`越界、忘记判空等错误） |
| 扩展性           | 可切换底层容器（`vector/list`）         | 需手动修改数组逻辑（如动态扩容需重写） |


### 二、各自优劣
#### 1. 标准库`stack`的优劣
##### 优势：
- **省心省力，减少bug**：无需手动维护`top`指针和数组大小，接口直接对应栈逻辑，避免因`top`更新错误（如漏写`top++`）、数组越界等低级错误。
- **动态适配内存**：底层容器（默认`deque`）支持动态扩容，无需提前预估数据量，既不会浪费内存（如数组过大），也不会出现容量不足的问题。
- **封装性强，逻辑安全**：屏蔽了底层容器的随机访问、迭代等操作，强制只能通过栈顶操作数据，避免误修改非栈顶元素，保证LIFO逻辑不被破坏。
- **扩展性好**：可直接指定底层容器（如`stack<int, vector<int>>`），适配不同场景（如需要内存连续选`vector`，需要灵活插入选`list`），无需重写核心逻辑。

##### 劣势：
- **轻微封装开销**：作为适配器，调用`push/pop/top`时会间接调用底层容器的接口（如`deque::push_back`），理论上存在极微小的封装开销（现代编译器优化下几乎可忽略）。
- **无法随机访问**：若需临时查看栈中非栈顶元素（不弹出），`stack`不支持，需改用数组模拟或其他容器。
- **内存开销略高**：底层容器（如`deque`）的动态扩容机制可能预留少量冗余内存，比固定大小的数组略占空间。


#### 2. 数组模拟栈的优劣
##### 优势：
- **极致简洁，无封装开销**：操作直接通过数组下标和`top`变量实现（如`st[++top] = x`），无函数调用、容器适配等额外开销，极端场景（如超大规模数据、嵌入式环境）下性能略优（感知有限）。
- **支持随机访问**：可直接通过数组下标访问任意位置元素（如`st[2]`），适合需要“既遵循栈逻辑，又偶尔查看中间元素”的特殊场景（虽破坏纯栈语义，但灵活）。
- **内存透明可控**：数组内存连续，可精确控制内存分配（如静态数组无需动态申请），适合内存受限的场景（如嵌入式系统、需严格控制内存使用的场景）。
- **适合学习底层**：手动维护`top`和边界判断，能直观理解栈的底层实现原理，适合初学者学习数据结构基础。

##### 劣势：
- **需手动处理边界和扩容**：静态数组需提前预估最大容量（预估过小会溢出，过大浪费内存）；动态数组（如`new int[N]`）需手动实现扩容逻辑（如数组满时重新申请更大空间、拷贝数据），代码繁琐。
- **错误风险高**：容易出现`top`越界（如`top >= N`或`top < -1`）、忘记判空就调用`top/pop`等错误，排查成本高。
- **破坏栈语义的风险**：支持随机访问可能导致误修改非栈顶元素（如`st[0] = 10`），违背LIFO的核心逻辑，增加代码维护难度。
- **扩展性差**：若需切换“底层存储结构”（如从连续数组改为链表），需完全重写栈的所有操作逻辑。


### 三、总结：该怎么选？
- 选标准库`stack`：算法题、常规项目开发、追求代码简洁性和稳定性时优先用。无需关注底层细节，能快速实现功能，减少出错概率，适配大多数场景。
- 选手动数组模拟栈：
  1. 学习数据结构底层原理（如理解栈的实现机制）；
  2. 内存受限场景（如嵌入式系统、静态内存环境）；
  3. 需随机访问栈中元素或极致控制内存/性能的特殊场景；
  4. 题目明确限制使用标准库容器（极少数算法题场景）。

本质上，两者的核心功能一致，差异集中在“使用便捷性”和“底层控制力”上——标准库`stack`是“开箱即用的工具”，数组模拟栈是“手动打造的零件”，按需选择即可。

---


