# 1. lower_bound(arr.begin(), arr.end(), aa)

在C++中，`lower_bound(arr.begin(), arr.end(), aa)`是标准库`<algorithm>`中提供的一个二分查找函数模板，**用于在有序序列中高效定位目标元素**。以下从多个维度总结其核心知识点：


### 一、是什么？
`lower_bound`是一个函数模板，用于在**已排序的序列**中查找**第一个大于等于目标值`aa`**的元素，返回该元素的迭代器。若序列中所有元素都小于`aa`，则返回尾迭代器（如`arr.end()`）。

其底层基于**二分查找算法**实现，默认使用`less<>`（即`<`运算符）作为比较规则，要求序列按升序排列；若需处理降序序列，可通过自定义比较函数调整逻辑。


### 二、什么用？
主要用于解决有序序列中的查找与定位问题，典型场景包括：
1. **查找目标值的插入位置**：在有序序列中插入`aa`后仍保持有序，`lower_bound`返回的迭代器即为插入点；
2. **判断目标值是否存在**：若返回的迭代器未指向尾迭代器，且该迭代器指向的元素等于`aa`，则`aa`存在于序列中；
3. **统计小于目标值的元素个数**：返回的迭代器与起始迭代器的距离（`it - arr.begin()`）即为小于`aa`的元素数量；
4. **处理重复元素**：在存在多个等于`aa`的元素时，可定位到第一个出现的位置。


### 三、怎么用？
#### 基本用法（升序序列）：
需包含头文件`<algorithm>`，调用时传入序列的起始迭代器、结束迭代器和目标值`aa`：
```cpp
#include <vector>
#include <algorithm>
using namespace std;

int main() {
    vector<int> arr = {1, 3, 5, 7, 9}; // 升序排列
    int aa = 5;
    // 查找第一个 >= 5 的元素
    auto it = lower_bound(arr.begin(), arr.end(), aa); 
    // 此时 it 指向 arr[2]（值为5）
    return 0;
}
```


#### 自定义比较（降序序列）：
若序列按降序排列，需传入自定义比较函数（如`greater<int>()`），此时`lower_bound`会查找**第一个小于等于`aa`**的元素（逻辑：找到第一个不满足`element > aa`的元素）：
```cpp
vector<int> arr = {9, 7, 5, 3, 1}; // 降序排列
int aa = 5;
// 传入 greater<int>()，查找第一个 <= 5 的元素
auto it = lower_bound(arr.begin(), arr.end(), aa, greater<int>()); 
// 此时 it 指向 arr[2]（值为5）
```


### 四、为什么用？
1. **高效性**：基于二分查找，时间复杂度为`O(log n)`（`n`为序列长度），远优于线性查找的`O(n)`，尤其适合大数据量场景；
2. **可靠性**：标准库实现经过严格测试，避免手动编写二分查找时可能出现的边界条件错误（如越界、循环退出条件错误等）；
3. **便捷性**：直接返回迭代器，可无缝配合容器的`insert`等操作（如插入元素保持有序），减少代码量。


### 五、优势与劣势
#### 优势：
- **高效**：二分查找保证了`O(log n)`的时间复杂度，适合大规模数据；
- **通用**：支持所有提供随机访问迭代器的容器（如`vector`、`array`、`deque`），且可通过自定义比较函数适配不同排序规则；
- **易用**：接口简洁，无需关注底层实现细节，降低开发成本。


#### 劣势：
- **依赖有序序列**：要求序列必须按比较规则提前排序，否则结果未定义（可能返回错误位置），增加了前置操作成本；
- **迭代器限制**：仅支持随机访问迭代器（如`list`的双向迭代器无法使用），因为二分查找需要计算中间位置（如`it + n`）；
- **自定义类型需适配**：对于自定义结构体/类，需重载`<`运算符（或提供对应比较函数），否则无法正确调用；
- **结果局限性**：仅返回第一个大于等于目标值的元素，若需查找最后一个小于等于目标值的元素，需使用`upper_bound`配合调整。


### 总结
`lower_bound`是C++中处理有序序列查找的高效工具，核心价值在于用二分查找简化定位逻辑，尤其适合需要维护**有序性**的场景。使用时需注意序列的排序状态和迭代器类型，以避免错误。

